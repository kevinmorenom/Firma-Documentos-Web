#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <sodium.h>

#define SIZE 8
#define R_SIZE 9

void sum32(uint32_t A[], uint32_t B[], uint32_t sum[], int length);
void rst32(uint32_t A[], uint32_t B[], uint32_t rst[], int length);
void mul32(uint32_t A[], uint32_t B[], uint32_t mul[], int length, int A_length, int B_length);
void mod_sum32(uint32_t A[], uint32_t B[], int m);
void mod_rst32(uint32_t A[], uint32_t B[], int m);
void barrett32(uint32_t T[], uint32_t P[], uint32_t result[], int T_length);
void mont32(uint32_t A[], uint32_t B[], uint32_t P[], uint32_t result[], int A_length, int B_length, int length);
void mul_mont32(uint32_t A[], uint32_t B[], uint32_t P[], uint32_t result[], int A_length, int B_length, int res_length);
void exp_mont32(uint32_t A[], uint32_t e[], uint32_t P[], uint32_t result[], int A_length, int e_length, int res_length);

int main(int argc, char* argv[]){
	if(sodium_init() == -1)
		return 1;
		
	// 32 bits * 8 = 256 bits
	uint32_t A[] = {0xb2cb88a2, 0xc7b617ae, 0xb75d44ee, 0xe15affc6, 0x65ca0674, 0xcb07e8cd, 0xd77f0a19, 0x3f7d2186};
	uint32_t B[] = {0x2d993abb, 0xd6fe1f86, 0x81dbe2ea, 0xce2d2848, 0x69b09840, 0x5cb39dae, 0x34a290ab, 0x959e0f57};
	uint32_t P[] = {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffff43};
	
	int i, j;

	// Generar números
	/*
	for(int i = 0; i<SIZE; i++){
		while(temp < 0x10000000)
			temp = randombytes_uniform(0xFFFFFFFF);
		A[i] = temp;
		temp = 0x00000000;
	}
	temp = 0x00000000;
	for(int i = 0; i<SIZE; i++){
		while(temp < 0x10000000)
			temp = randombytes_uniform(0xFFFFFFFF);
		B[i] = temp;
		temp = 0x00000000;
	}
	*/
	printf("A: ");
	for(i = 0; i<SIZE; i++){
		for(j=7; j>=0; j--){
			if((A[i] >> 4*j) & 0x0000000F == 0)
				printf("0");
			else
				printf("%x", (A[i] >> 4*j) & 0x0000000F);
		}
	}
	printf("\nB: ");
	for(i = 0; i<SIZE; i++){
		for(j=7; j>=0; j--){
			if((B[i] >> 4*j) & 0x0000000F == 0)
				printf("0");
			else
				printf("%x", (B[i] >> 4*j) & 0x0000000F);
		}
	}
	printf("\n\n");

	// Suma
	uint32_t* suma = (uint32_t*)malloc(SIZE*sizeof(uint32_t));
	sum32(A, B, suma, SIZE);
	printf("Suma: ");
	for(int i = 0; i<SIZE; i++) printf("[%x]", suma[i]);
	printf("\n\n");
	free(suma);
	
	
	// Resta
	uint32_t* resta = (uint32_t*)malloc(SIZE*sizeof(uint32_t));
	rst32(A, B, resta, SIZE);
	printf("Resta: ");
	for(int i = 0; i<SIZE; i++) printf("[%x]", resta[i]);
	printf("\n\n");
	
	
	//Multiplicación
	uint32_t* multiplicacion = (uint32_t*)malloc(SIZE*2 * sizeof(uint32_t));
	mul32(A, B, multiplicacion, SIZE*2, SIZE, SIZE);
	printf("Multiplicacion = ");
	for(int i = 0; i<SIZE*2; i++) printf("[%x]", multiplicacion[i]);
	printf("\n\n");
	
	
	// Suma Modular
	//mod_sum32(A, B, 0x3b6bd40);
	
	// Resta Modular
	//mod_rst32(A, B, 0x3b6bd40);
	
	// Barrett Reduction Multiplication
	uint32_t* barrett = (uint32_t*)malloc(SIZE * sizeof(uint32_t));
	barrett32(multiplicacion, P, barrett, SIZE*2);
	printf("Barret = ");
	for(int i=0; i<(32*(SIZE+1))/32; i++) printf("[%x]", barrett[i]);
	printf("\n\n");
	
	
	// Montgomery Reduction
	int32_t* mont = (uint32_t*)malloc(SIZE * sizeof(uint32_t));
	mont32(A, B, P, mont, SIZE, SIZE, SIZE);
	printf("Montgomery = ");
	for(int i=0; i<SIZE; i++) printf("[%x]", mont[i]);
	printf("\n\n");
	
	// Montgomery Multiplication
	uint32_t* mul_mont = (uint32_t*)malloc(SIZE * sizeof(uint32_t));
	mul_mont32(A, B, P, mul_mont, SIZE, SIZE, SIZE);
	printf("Mont Mul= ");
	for(int i=0; i<(32*(SIZE+1))/32; i++) printf("[%x]", barrett[i]);
	printf("\n\n");
	
	
	// Montgomery Exponentiation
	uint32_t* exp_mont = (uint32_t*)malloc(SIZE * sizeof(uint32_t));
	exp_mont32(A, B, P, exp_mont, SIZE, SIZE, SIZE);
	uint32_t exp_mont_2[] = {0x75264e2d,
							 0x0973d51c,
							 0xa6caee06,
							 0x52b8d5ab,
							 0xb1ef9940,
							 0xff82a8c9,
							 0x705a65cc,
							 0x59ae2332};
	printf("EXP Mul= ");
	for(int i=0; i<SIZE; i++) printf("[%x]", exp_mont_2[i]);
	printf("\n\n");
	
	
}

void sum32(uint32_t A[], uint32_t B[], uint32_t sum[], int length){
	uint32_t* temp_sum = (uint32_t*)malloc(length*sizeof(uint32_t));
	uint64_t temp64;
	int carry = 0;
	int i, j;

	for(i=length-1; i>=0; i--){
		temp64 = (uint64_t) A[i] + B[i] + carry;
		temp_sum[i] = (uint32_t) temp64;
		carry = (temp64 >> 32) != 0;
	}
	for(i=0; i<length; i++) sum[i] = temp_sum[i];
	free(temp_sum);
}

void rst32(uint32_t A[], uint32_t B[], uint32_t rst[], int length){
	uint32_t* temp_rst = (uint32_t*)malloc(length*sizeof(uint32_t));
	uint64_t temp64;
	int borrow = 0;
	int i, j;

	uint32_t mask = 0xFFFFFFFF;
	for(int i=length-1; i>=0; i--){
		temp64 = (uint64_t) A[i] - B[i] - borrow;
		temp_rst[i] = temp64 & mask;
		borrow = (temp64 >> 32) != 0;
	}
	for(i=0; i<length; i++) rst[i] = temp_rst[i];
	free(temp_rst);
}

void mul32(uint32_t A[], uint32_t B[], uint32_t mul[], int length, int A_length, int B_length){
	uint64_t temp64;
	uint32_t carry = 0;
	uint32_t* temp_mul = (uint32_t*)malloc(length*sizeof(uint32_t));
	int i, j;
	
	for(i=0; i<length; i++) temp_mul[i] = 0;
	
	uint32_t REV_A[A_length], REV_B[B_length];
	for(i=A_length-1, j=0; i >=0; i--, j++) REV_A[j] = A[i];
	for(i=B_length-1, j=0; i >=0; i--, j++) REV_B[j] = B[i];
	
	for(i=0; i<B_length; i++){
		carry = 0;
		for(j=0; j<A_length; j++){
			temp64 = (uint64_t) temp_mul[i+j] + (uint64_t) REV_A[j]*REV_B[i] + (uint64_t)carry;
			temp_mul[i+j] = (uint32_t)temp64;
			carry = temp64 >> 32;
		}
		temp_mul[i+j] = carry;
	}
	for(i=length-1, j=0; i>=0; i--, j++) mul[j] = temp_mul[i];
	free(temp_mul);
}

void mod_sum32(uint32_t A[], uint32_t B[], int m){
	uint32_t sum[SIZE];
	uint64_t temp64;
	int carry = 0;

	for(int i=SIZE-1; i>=0; i--){
		temp64 = (uint64_t) A[i] + B[i] + carry;
		sum[i] = (uint32_t) temp64;
		carry = (temp64 >> 32) != 0;
	}
	
	uint32_t mask = 0x0000000F;
	int current = 0, result = 0;
	
	if(carry == 1)
		result = 1 % m;
	for(int i=0; i<SIZE; i++){
		for(int j=7; j>=0; j--){
			current = (sum[i]>>(j*4))&mask;
			result = (result*16 + current) % m;
			//printf("%x: %x\n", current, result);
		}
	}
	
	printf("Suma Modular: %x\n", result);
	printf("\n");
}

void mod_rst32(uint32_t A[], uint32_t B[], int m){
	uint32_t rst[SIZE];
	uint64_t temp64;
	int borrow = 0;

	uint32_t mask = 0xFFFFFFFF;
	for(int i=SIZE-1; i>=0; i--){
		temp64 = (uint64_t) A[i] - B[i] - borrow;
		rst[i] = temp64 & mask;
		borrow = (temp64 >> 32) != 0;
		//printf("%x - borrow: %d\n", rst[i], borrow);
	}
	
	mask = 0x0000000F;
	int current = 0, result = 0;
	
	for(int i=0; i<SIZE; i++){
		for(int j=7; j>=0; j--){
			current = (rst[i]>>(j*4))&mask;
			result = (result*16 + current) % m;
			//printf("%x = ")
			//printf("%x: %x\n", current, result);
		}
	}
	printf("Resta Modular: %x\n", result);
	printf("\n");
}

void barrett32(uint32_t T[], uint32_t P[], uint32_t result[], int T_length){
	int i, j;
// b = 2^32
// k
	int k = 256/(SIZE*4); // Un valor 'P' de 256, divido en W de 32 bits + 1
	//printf("k = %d\n", k);

// MIU
	uint32_t MIU[] = {0x1, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000000bd};
	
// Q1 = t/b^(k-1) --> t >> 2 ^ 32*(k-1)
	int Q1_length = T_length - (32*(k-1))/32;
	uint32_t* Q1 = (uint32_t*)malloc(Q1_length * sizeof(uint32_t)); 
	for(i=0; i < Q1_length; i++) Q1[i] = T[i];
	/*
	printf("Q1 = ");
	for(i=0; i<Q1_length; i++) printf("[%x]", Q1[i]);
	printf("\n");
	*/
// Q2 = Q1 * MIU
	uint32_t* Q2 = (uint32_t*)malloc(Q1_length * sizeof(uint32_t));
	mul32(Q1, MIU, Q2, Q1_length*2, Q1_length, Q1_length);
	/*
	printf("Q2 = ");
	for(i=0; i<Q1_length*2; i++) printf("[%x]", Q2[i]);
	printf("\n");
	*/
// Q = Q2 * (1 / b^(k+1)) --> Q2 / 2 ^ 32*(k+1)
	int Q_length = Q1_length*2 - (32*(k+1))/32;
	uint32_t* Q = (uint32_t*)malloc(Q_length * sizeof(uint32_t));
	for(i=0; i < Q_length; i++) Q[i] = Q2[i];
	/*
	printf("Q = ");
	for(i=0; i<Q_length; i++) printf("[%x]", Q[i]);
	printf("\n");
	*/

// R1 = T mod b^(k+1)
	int R1_length = (32*(k+1))/32;
	uint32_t* R1 = (uint32_t*)malloc(R1_length * sizeof(uint32_t));
	for(i=0, j=T_length-R1_length; i<R1_length; i++, j++) R1[i] = T[j];
	/*
	printf("R1 = ");
	for(i=0; i<R1_length; i++) printf("[%x]", R1[i]);
	printf("\n");
	*/
// R2 = Q * P
	uint32_t* R2 = (uint32_t*)malloc(SIZE*2 * sizeof(uint32_t));
	mul32(Q, P, R2, SIZE*2, Q_length, SIZE);
	/*
	printf("R2 = ");
	for(i=0; i<SIZE*2; i++) printf("[%x]", R2[i]);
	printf("\n");
	*/
	
// R3 = R2 mod b^(k+1)
	int R3_length = (32*(k+1))/32;
	uint32_t* R3 = (uint32_t*)malloc(R3_length * sizeof(uint32_t));
	for(i=0, j=T_length-R3_length; i<R3_length; i++, j++) R3[i] = R2[j];
	/*
	printf("R3 = ");
	for(i=0; i<R3_length; i++) printf("[%x]", R3[i]);
	printf("\n");
	*/

// R = R1 - R3
	uint32_t* R = (uint32_t*)malloc(R3_length * sizeof(uint32_t));
	rst32(R1, R3, R, R3_length);
	/*
	printf("BARR - R = ");
	for(int i = 0; i<R3_length; i++) printf("[%x]", R[i]);
	printf("\n");
	*/
	
// R < 0 then R = R + b^(k+1)
	int flag = 0;
	for(int i=0; i<R1_length; i++){
		if(R1[i] > R3[i]){
			flag = 1;
			break;
		}
	}
	if(flag == 0){
		printf("\nWARNING: R < 0\n");
		uint32_t* newR = (uint32_t*)malloc((R3_length+1) * sizeof(uint32_t));
		newR[0] = 0x1;
		for(i=0; i<R3_length; i++) newR[i+1] = R[i];
		
		for(int i = 0; i<R3_length; i++) result[i] = newR[i];
		/*
		printf("R = ");
		for(int i = 0; i<R3_length+1; i++) printf("[%x]", newR[i]);
		printf("\n");
		*/
	} else {
		for(int i = 0; i<R3_length; i++) result[i] = R[i];
		/*
		printf("R = ");
		for(int i = 0; i<R3_length; i++) printf("[%x]", R[i]);
		printf("\n");
		*/
	}
}

void mont32(uint32_t A[], uint32_t B[], uint32_t P[], uint32_t result[], int A_length, int B_length, int res_length){
	//printf("\n\n MONTOGOMERY...\n");
	int i,j;
	int k = 256/(SIZE*4);
	
	uint32_t R[] = {0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
	
// RES_A = (A*R) mod P
	uint32_t* temp_RES_A = (uint32_t*)malloc(A_length*2 * sizeof(uint32_t));
	mul32(A, R, temp_RES_A, A_length*2, A_length, sizeof(R)/sizeof(R[0]));
	
	int RES_A_length = A_length + 1;
	uint32_t* RES_A = (uint32_t*)malloc(RES_A_length * sizeof(uint32_t));
	barrett32(temp_RES_A, P, RES_A, A_length*2);
	free(temp_RES_A);
	/*
	printf("RES_A = ");
	for(i = 0; i<RES_A_length; i++) printf("[%x]", RES_A[i]);
	printf("\n");
	*/
	
// RES_B = (B*R) mod P
	uint32_t* temp_RES_B = (uint32_t*)malloc(B_length*2 * sizeof(uint32_t));
	mul32(B, R, temp_RES_B, B_length*2, B_length, sizeof(R)/sizeof(R[0]));
	
	int RES_B_length = B_length + 1;
	uint32_t* RES_B = (uint32_t*)malloc(RES_B_length * sizeof(uint32_t));
	barrett32(temp_RES_B, P, RES_B, B_length*2);
	free(temp_RES_B);
	/*
	printf("RES_B = ");
	for(i = 0; i<RES_B_length; i++) printf("[%x]", RES_B[i]);
	printf("\n");
	*/
	
// P_INV = -modinv(P, R) % P
	uint32_t P_INV[] = {0x4fea53fa, 0x94fea53f, 0xa94fea53, 0xfa94fea5, 0x3fa94fea, 0x53fa94fe, 0xa53fa94f, 0xea53fa95};
	
// T = RES_A * RES_B
	int T_length = RES_A_length*2;
	uint32_t* T = (uint32_t*)malloc(T_length * sizeof(uint32_t));
	mul32(RES_A, RES_B, T, T_length, RES_A_length, RES_B_length);
	/*
	printf("T = ");
	for(i = 0; i<T_length; i++) printf("[%x]", T[i]);
	printf("\n\n");
	*/
	
// Q1 = T * P_INV
	int Q1_length = T_length*2;
	uint32_t* Q1 = (uint32_t*)malloc(Q1_length * sizeof(uint32_t));
	mul32(T, P_INV, Q1, Q1_length, T_length, SIZE);
	
	int cnt = 0;
	for(i = 0; i<Q1_length; i++)
		if(Q1[i] == 0) cnt++;
	
	Q1_length = Q1_length - cnt;
	uint32_t* Q1_clean = (uint32_t*)malloc(Q1_length * sizeof(uint32_t));
	for(i = cnt, j=0; i<Q1_length+cnt; i++, j++) Q1_clean[j] = Q1[i]; 
	/*
	printf("Q1_clean = ");
	for(int i = 0; i<Q1_length; i++) printf("[%x]", Q1_clean[i]);
	printf("\n\n");
	*/
	
// Q = Q1 mod R
	int Q_length = (32*k)/32;
	uint32_t* Q = (uint32_t*)malloc(Q_length * sizeof(uint32_t));
	for(i=0, j=Q1_length-Q_length; i<Q_length; i++, j++) Q[i] = Q1_clean[j];
	/*
	printf("Q = ");
	for(i=0; i<Q_length; i++) printf("[%x]", Q[i]);
	printf("\n");
	*/
	
// U1 = Q * P
	int U1_length = Q_length*2;
	uint32_t* U1 = (uint32_t*)malloc(U1_length * sizeof(uint32_t));
	mul32(Q, P, U1, U1_length, Q_length, SIZE);
	/*
	printf("U1 = ");
	for(i = 0; i<U1_length; i++) printf("[%x]", U1[i]);
	printf("\n\n");
	*/
	
// U2 = T + U1	
	cnt = 0;
	for(i = 0; i<T_length; i++)
		if(T[i] == 0) cnt++;

	T_length = T_length - cnt;
	uint32_t* T_clean = (uint32_t*)malloc(T_length * sizeof(uint32_t));
	for(i = cnt, j=0; i<T_length+cnt; i++, j++) T_clean[j] = T[i]; 
	
	int U2_length = U1_length;
	uint32_t* U2 = (uint32_t*)malloc(U2_length * sizeof(uint32_t));
	sum32(T_clean, U1, U2, U2_length);
	/*
	printf("U2 = ");
	for(i = 0; i<U2_length; i++) printf("[%x]", U2[i]);
	printf("\n\n");
	*/
	
// U = U2 / R;
	int U_length = (32*k)/32;
	uint32_t* U = (uint32_t*)malloc(U_length * sizeof(uint32_t)); 
	for(i=0; i < U_length; i++) U[i] = U2[i];
	/*
	printf("U = ");
	for(i=0; i<U_length; i++) printf("[%x]", U[i]);
	printf("\n");
	*/
	
// U > P then U - P
	int flag = 0;
	for(i=0; i<U_length; i++){
		if(U[i] > P[i]){
			flag = 1;
			break;
		}
	}
	if(flag == 1){
		printf("Warning\n");
		rst32(U, P, result, res_length);
	}
	else
		for(i=0; i<U_length; i++) result[i] = U[i];
	
}

void mul_mont32(uint32_t A[], uint32_t B[], uint32_t P[], uint32_t result[], int A_length, int B_length, int res_length){
	int i,j;
	int k = 256/(SIZE*4);
	
	uint32_t R[] = {0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
	
// RES_A = (A*R) mod P
	uint32_t* temp_RES_A = (uint32_t*)malloc(A_length*2 * sizeof(uint32_t));
	mul32(A, R, temp_RES_A, A_length*2, A_length, sizeof(R)/sizeof(R[0]));
	
	int RES_A_length = A_length + 1;
	uint32_t* RES_A = (uint32_t*)malloc(RES_A_length * sizeof(uint32_t));
	barrett32(temp_RES_A, P, RES_A, A_length*2);
	free(temp_RES_A);
	
	int cnt = 0;
	for(i = 0; i<RES_A_length; i++)
		if(RES_A[i] == 0) cnt++;
	
	RES_A_length = RES_A_length - cnt;
	uint32_t* RES_A_clean = (uint32_t*)malloc(RES_A_length * sizeof(uint32_t));
	for(i = cnt, j=0; i<RES_A_length+cnt; i++, j++) RES_A_clean[j] = RES_A[i];
	/*
	printf("RES_A = ");
	for(i = 0; i<RES_A_length; i++) printf("[%x]", RES_A_clean[i]);
	printf("\n");
	*/
	
// RES_C = montgomery32(RES_A, B)
	int RES_C_length = RES_A_length;
	uint32_t* temp_RES_C = (uint32_t*)malloc(RES_C_length * sizeof(uint32_t));
	mont32(RES_A_clean, B, P, temp_RES_C, RES_A_length, B_length, RES_C_length);
	/*
	printf("RES_C = ");
	for(i = 0; i<RES_C_length; i++) printf("[%x]", temp_RES_C[i]);
	printf("\n");
	*/
	
	for(i = 0; i<RES_C_length; i++) result[i] = temp_RES_C[i];
	
}

void exp_mont32(uint32_t A[], uint32_t e[], uint32_t P[], uint32_t result[], int A_length, int e_length, int res_length){
	int i,j;
	int k = 256/(SIZE*4);
	
	uint32_t R[] = {0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
	
// RES_A = (A*R) mod P
	uint32_t* temp_RES_A = (uint32_t*)malloc(A_length*2 * sizeof(uint32_t));
	mul32(A, R, temp_RES_A, A_length*2, A_length, sizeof(R)/sizeof(R[0]));
	
	int RES_A_length = A_length + 1;
	uint32_t* RES_A = (uint32_t*)malloc(RES_A_length * sizeof(uint32_t));
	barrett32(temp_RES_A, P, RES_A, A_length*2);
	free(temp_RES_A);
	
	int cnt = 0;
	for(i = 0; i<RES_A_length; i++)
		if(RES_A[i] == 0) cnt++;
	
	RES_A_length = RES_A_length - cnt;
	uint32_t* RES_A_clean = (uint32_t*)malloc(RES_A_length * sizeof(uint32_t));
	for(i = cnt, j=0; i<RES_A_length+cnt; i++, j++) RES_A_clean[j] = RES_A[i];

// MAYOR_A = R mod P
	int MAYOR_A_length = 1;
	uint32_t MAYOR_A[] = {0xbd};
	
	uint32_t* M1 = (uint32_t*)malloc(MAYOR_A_length*2 * sizeof(uint32_t));
	
// FOR cycle
	for(i=0; i<e_length; i++){
		for(j=7; j>=0; j--){
			//mont32(MAYOR_A, MAYOR_A, P, MAYOR_A, MAYOR_A_length, MAYOR_A_length, MAYOR_A_length);
			if(e[i]>>(j*4) == 1) ;
				//mont32(MAYOR_A, RES_A, P, MAYOR_A, MAYOR_A_length, MAYOR_A_length, MAYOR_A_length);
		}
	}
	//mont32(MAYOR_A, 1, P, result, MAYOR_A_length, 1, MAYOR_A_length);
}








